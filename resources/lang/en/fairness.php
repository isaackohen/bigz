<?php

return [
    'tabs' => [
        'overview' => 'Overview',
        'dev' => 'Implementation',
        'transform' => 'Conversion',
        'events' => 'Game events',
        'calculator' => 'Сalculator'
    ],
    'overview' => [
        '1' => "<h6>Solving the Trust Issue with Online Gambling</h6>
                <p>The underlying concept of provable fairness is that players have the ability to prove and verify that their results are fair and unmanipulated. This is achieved through the use of a commitment scheme, along with cryptographic hashing.</p>
                <p>The commitment scheme is used to ensure that the player has an influence on all results generated. Cryptographic hashing is used to ensure that the casino also remains honest to this commitment scheme. Both concepts combined creates a trust-less environment when gambling online.</p>
                <p>This is simplified in the following representation:</p>"
    ],
    'dev' => [
        '1' => "<h6> Random Number Generation </h6>
        <p> For each bet being checked, we use: client seed, server seed, nonce and cursor as input parameters for the random number generation function.
        The function uses the <strong> HMAC_SHA256 </strong> cryptographic hash to generate bytes, which are then used as the basis for how we generate reliably random results on our platform. </p> ",
        '2' => "<h6 class = 'mt-4'> Server LED </h6>
        The server seed is generated by our system in the form of a random string of 32 characters before the start of the game, which you cannot recognize until it is completed. The reason why we do not provide you with a server seed at any time is that in this case the player would be able to calculate the results of the games in advance.
        <h6 class = 'mt-4'> Client led </h6>
        The client seed is owned by the player and is used to ensure that the player also influences the randomness of the generated results. Without this component of the algorithm, only the server seed will have a complete influence on the result of each bet.
        All players are free to edit and change their client side regularly to create a new chain of random upcoming results. This ensures that the player has absolute control over the generation of the result, like cutting a deck in a regular casino.
        During registration, your browser creates a client seed to ensure the smooth operation of the site. Although this randomly generated client seed is considered appropriate, we strongly recommend that you choose your own so that your influence is included in randomness.
        You can do this in your profile settings.
        <h6 class = 'mt-4'> Nonce </h6>
        Nonce is simply a number that increases by 1 with every new bet you make. Due to the peculiarities of the SHA256 cryptographic function, a completely new result is created each time.
        The implementation of nonce ensures that we remain committed to your client and server pair, while at the same time generating new results for every bet made.
        <h6 class = 'mt-4'> Cursor </h6>
        We use 4 bytes of data to generate one game result. Since SHA256 is limited to 32 bytes, we use this cursor implementation to enable us to create more game events without having to change our provable honesty algorithm.
        The cursor is iterated only when the game requires more than 8 (32 bytes / 4 bytes) possible results. For example: when we need to use more than 8 cards in a blackjack game.
        The cursor starts at 0 and increments by 1 each time 32 bytes are returned by the HMAC_SHA256 function. If we do not need more than 8 random numbers to be generated for game events, the cursor does not increase because there is no need to generate any additional possible game results. "
    ],
    'transform' => [
        '1' => "<h6>Floating point bytes</h6>
                <p>The result of the random number generator (byteGenerator) function is a hexadecimal 32-byte hash.
                As explained in the cursor implementation, we use 4 bytes of data to generate one game result.
                Each set of 4 bytes is used to generate floating point values ​​ranging from 0 to 1
                (4 bytes are used instead of one to provide a higher level of accuracy when generating floating point numbers.)
                It is with these generated numbers that we get the formal result of the provable honest algorithm before it is translated into game events. </p> ",
'2' => "<h6 class = 'mt-4'> Floating point numbers in game events </h6>
                <p> Since the random number generation process is universal for all our games,
                It is at this stage of the generation of the game result that a unique procedure is implemented,
                allowing you to determine the transfer from a floating point number to game events.
                A randomly generated result is multiplied by the possible remaining results of a particular game.
                For example: in a game that uses a deck of 52 cards, this can be done by simply multiplying the number by 52.
                The result of this equation is then converted to the corresponding game event.
                For games where multiple game events are required, this process continues every 4 bytes in the result chain,
                which was generated using the described byteGenerator function. </p>
                <h6 class = 'mt-4'> Shuffle game events </h6>
                <p> For games like Keno, Mines, and Video Poker, where the results cannot be duplicated, we use the random shuffling algorithm <a href = 'https: //en.wikipedia.org/wiki/Fisher%E2%80% 93Yates_shuffle 'target =' _ blank '> Fisher Yates </a>. </p> "
    ],
    'events' => [
        '1' => "<p> Game events are the translation of randomly generated numbers into the corresponding game-specific result.
            This includes everything from the outcome of a roll of dice to the order of the cards in the deck, or even the location of each bomb in Mines.
            The following is a detailed explanation of how we translate numbers into events for each specific game on our platform. </p>
            <h6> Blackjack, Hilo & Baccarat </h6>
            <p> There are 52 unique possible outcomes in the standard deck of cards: </p> ",
        '2' => "<h6> Diamonds </h6>
            <p> When playing Diamonds, there are 7 possible outcomes in the form of diamonds. To achieve this, we multiply each floating-point number by 7,
            and then translate it into the corresponding diamond: </p> ",
        '3' => "<p> Then the player receives 5 diamonds. </p>
            <h6> Dice </h6>
            <p> In our version of the Dice game, we cover the possible throw spread from 00.00 to 100.00,
            which has a range of 10,001 possible results.
            Translation of game events is performed by multiplying the floating point number by the number of possible results,
            and then divide by 100 so that the resulting number matches the limits of our declared range of dice. </p> ",
        '4' => "<h6> Limbo </h6>
            <p> When it comes to Limbo, we use a two-step process.
            Firstly, we take the number and multiply it by the maximum possible multiplier and by% of the casino advantage.
            Then, to generate a game event using the <a href='https://en.wikipedia.org/wiki/Probability_distribution' target='_blank'> probability distribution </a>,
            we divide the maximum possible factor by the result of the first step to create a game event in the form of a final coefficient. </p> ",
            '5' => "<h6> Plinko </h6>
            <p> For any Plinko game, the generated result is based on which cell the ball will fall into. </p> ",
            '6' => "<h6> Roulette </h6>
            <p> Our roulette is taken from the European version of the game, in which the wheel consists of 37 different possible pockets in the range from 0 to 36.
            A game event is calculated by multiplying the number by 37, and then transferred to the appropriate pocket: </p> ",
        '7' => "<h6> Keno </h6>
            <p> Traditional Keno games require a selection of 10 possible game events in the form of cells on the game board.
            To achieve this, we multiply each floating-point number by the number of unique squares possible. </p> ",
        '8' => "<p> The implementation of a random Fisher-Yates sequence is used to prevent duplication of possible hits. </p>
            <h6> Mines </h6>
            <p> Mines consists of 24 separate game events in the form of mines on the playing field.
            Each number is multiplied by the number of possible unique tiles still remaining on the board.
            Cell locations are constructed using the grid position from left to right, from top to bottom.
            The implementation of a random Fisher-Yates sequence is used to prevent duplication of possible hits.
            Depending on the selected settings, 2 to 24 results of game events are used. </p>
            <h6> Video Poker </h6>
            <p> Playing Video Poker includes 52 individual game events in the form of cards in the deck.
            Each number is multiplied by the number of possible cards remaining in the deck. </p> ",
        '9' => "<p> The implementation of a random Fisher-Yates sequence is used to prevent duplication of possible hits. </p>"
    ],
    'calculator' => [
        'game' => 'Game',
        'client_seed' => 'Client seed',
        'nonce' => 'Nonce',
        'server_seed' => 'Server seed',
        'result' => 'Result',
    ]
];
